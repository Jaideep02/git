from time import sleep

from .solver import *
from .entry_operations import (
    insert_value,
    delete_value,
    update_values, 
    collect_entry_values,
    update_values)

from src.gui.style.entry_color_change import (
    bg_to_red,
    bg_to_green,
    bg_to_blue,
    fg_to_blue,
    fg_to_white
)

IS_CLEAR = None
IS_VISUAL = None
HINT_BOARD = None
ENTRY_LIST = None
MASTER = None
RUN = True

select_time = 0.00
green_time = 0.05
red_time = 0.04

#function used to stop the solving process
def stop_solving():
    global RUN
    RUN = False

#variables are passed as arguments to the function and are used to control the behavior of the solving
# process, such as whether it is a visual solve or not, whether the board is generated by the game or 
#input by the user, and the master window and entry list of the GUI.
def setup_visual_solve(master,entry_list, hint_board, is_clear, is_visual):
    global IS_CLEAR, IS_VISUAL, HINT_BOARD, ENTRY_LIST, MASTER, RUN

    IS_CLEAR = is_clear
    IS_VISUAL = is_visual
    HINT_BOARD = hint_board
    ENTRY_LIST = entry_list
    MASTER = master
    RUN = True
   
   
 # speed_visual_solve(), is the main function that solves the Sudoku puzzle.
 #  It takes a single argument, board, which is the current state of the puzzle. 
 # The function uses a backtracking algorithm to solve the puzzle. If the IS_VISUAL flag is set,
 #  the function will update the GUI as it solves the puzzle. The function also uses the RUN variable to 
 # check whether the solving process should be stopped. The function uses several helper functions such as 
 # find_empty, valid, update_values, bg_to_red, bg_to_green, fg_to_white, delete_value, insert_value, sleep 
 # to update the GUI and solve the puzzle.

def speed_visual_solve(board):
    
    # if game not generated | input by user
    if not IS_VISUAL and IS_CLEAR:
        solve(board)
        update_values(board, ENTRY_LIST)
        return

    # Speed Solve | Game Generated
    if not IS_VISUAL:
        update_values(HINT_BOARD, ENTRY_LIST)

    # visual Solve
    if IS_VISUAL:
        find = find_empty(board)

        if not find:
            return True
        else:
            row, col = find

        for i in range(1,10):
            
            if IS_VISUAL and RUN:   # select
                bg_to_red(ENTRY_LIST[row][col])
                fg_to_white(ENTRY_LIST[row][col])
                delete_value(ENTRY_LIST[row][col])
                insert_value(ENTRY_LIST[row][col],i)
                MASTER.update()
                sleep(select_time)

            if valid(board, i, (row, col)):

                if IS_VISUAL and RUN:   # green / valid
                    bg_to_green(ENTRY_LIST[row][col])
                    delete_value(ENTRY_LIST[row][col])
                    insert_value(ENTRY_LIST[row][col],i)
                    MASTER.update()
                    sleep(green_time)
                
                board[row][col] = i

                if speed_visual_solve(board):
                    return True

                board[row][col] = 0

                if IS_VISUAL and RUN:
                    bg_to_red(ENTRY_LIST[row][col])
                    fg_to_white(ENTRY_LIST[row][col])
                    delete_value(ENTRY_LIST[row][col])
                    insert_value(ENTRY_LIST[row][col],0)
                    MASTER.update()
                    sleep(red_time)

        return False